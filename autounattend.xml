<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
	<!-- Optimized by Jules - Senior Windows Deployment Architect -->
	<settings pass="offlineServicing"></settings>
	<settings pass="windowsPE">
		<component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<UILanguage>fr-FR</UILanguage>
		</component>
		<component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<UserData>
				<ProductKey>
					<Key>VK7JG-NPHTM-C97JM-9MPGT-3V66T</Key>
					<WillShowUI>OnError</WillShowUI>
				</ProductKey>
				<AcceptEula>true</AcceptEula>
			</UserData>
			<UseConfigurationSet>false</UseConfigurationSet>
		</component>
	</settings>
	<settings pass="generalize"></settings>
	<settings pass="specialize">
		<component name="Microsoft-Windows-Deployment" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<RunSynchronous>
				<RunSynchronousCommand wcm:action="add">
					<Order>1</Order>
					<Path>powershell.exe -WindowStyle "Hidden" -NoProfile -Command "$xml = [xml]::new(); $xml.Load('C:\Windows\Panther\unattend.xml'); $sb = [scriptblock]::Create( $xml.unattend.Extensions.ExtractScript ); Invoke-Command -ScriptBlock $sb -ArgumentList $xml;"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>2</Order>
					<Path>powershell.exe -WindowStyle "Hidden" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\Windows\Setup\Scripts\Specialize.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>3</Order>
					<Path>reg.exe load "HKU\DefaultUser" "C:\Users\Default\NTUSER.DAT"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>4</Order>
					<Path>powershell.exe -WindowStyle "Hidden" -ExecutionPolicy "Unrestricted" -NoProfile -File "C:\Windows\Setup\Scripts\DefaultUser.ps1"</Path>
				</RunSynchronousCommand>
				<RunSynchronousCommand wcm:action="add">
					<Order>5</Order>
					<Path>reg.exe unload "HKU\DefaultUser"</Path>
				</RunSynchronousCommand>
			</RunSynchronous>
		</component>
	</settings>
	<settings pass="auditSystem"></settings>
	<settings pass="auditUser"></settings>
	<settings pass="oobeSystem">
		<component name="Microsoft-Windows-International-Core" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<InputLocale>040c:0000040c</InputLocale>
			<SystemLocale>fr-FR</SystemLocale>
			<UILanguage>fr-FR</UILanguage>
			<UserLocale>fr-FR</UserLocale>
		</component>
		<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<UserAccounts>
				<LocalAccounts>
					<LocalAccount wcm:action="add">
						<Name>User</Name>
						<DisplayName></DisplayName>
						<Group>Administrators</Group>
						<Password>
							<Value></Value>
							<PlainText>true</PlainText>
						</Password>
					</LocalAccount>
				</LocalAccounts>
			</UserAccounts>
			<AutoLogon>
				<Username>User</Username>
				<Enabled>true</Enabled>
				<LogonCount>1</LogonCount>
				<Password>
					<Value></Value>
					<PlainText>true</PlainText>
				</Password>
			</AutoLogon>
			<OOBE>
				<ProtectYourPC>3</ProtectYourPC>
				<HideEULAPage>true</HideEULAPage>
				<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
				<HideOnlineAccountScreens>false</HideOnlineAccountScreens>
			</OOBE>
		</component>
	</settings>
	<Extensions xmlns="https://schneegans.de/windows/unattend-generator/">
		<ExtractScript>

param(
    [xml] $Document
);

foreach( $file in $Document.unattend.Extensions.File ) {
    $path = [System.Environment]::ExpandEnvironmentVariables( $file.GetAttribute( 'path' ) );
    mkdir -Path( $path | Split-Path -Parent ) -ErrorAction 'SilentlyContinue';
    $encoding = switch( [System.IO.Path]::GetExtension( $path ) ) {
        { $_ -in '.ps1', '.xml' } { [System.Text.Encoding]::UTF8; }
        { $_ -in '.reg', '.vbs', '.js' } { [System.Text.UnicodeEncoding]::new( $false, $true ); }
        default { [System.Text.Encoding]::Default; }
    };
    $bytes = $encoding.GetPreamble() + $encoding.GetBytes( $file.InnerText.Trim() );
    [System.IO.File]::WriteAllBytes( $path, $bytes );
}

		</ExtractScript>
		<File path="C:\Windows\Setup\Scripts\Lib\Helper.ps1">
function Get-InstallMedia {
    $drives = Get-PSDrive -PSProvider FileSystem
    foreach ($drive in $drives) {
        $path = Join-Path -Path $drive.Root -ChildPath &quot;drivers&quot;
        if (Test-Path -Path $path -PathType Container) {
            return $drive.Root
        }
    }
    return $null
}

function Get-InstallerFile {
    param([string]$Path)
    if (Test-Path -Path $Path) {
        $file = Get-ChildItem -Path $Path -Filter &quot;*.exe&quot; | Select-Object -First 1
        if ($file) { return $file.FullName }
    }
    return $null
}

function Write-Log {
    param(
        [string]$Message,
        [string]$Path = &quot;$env:SystemRoot\Setup\Scripts\Setup.log&quot;
    )
    $timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;
    $logEntry = &quot;[$timestamp] $Message&quot;
    Add-Content -Path $Path -Value $logEntry -ErrorAction SilentlyContinue
    # Write-Host is useful for debugging but we want total silence in production
    # Write-Host $logEntry
}

function Download-File {
    param(
        [string]$Url,
        [string]$Destination,
        [string]$Name = &quot;File&quot;
    )

    if ([string]::IsNullOrWhiteSpace($Url)) { return $false }

    Write-Log &quot;Attempting to download $Name from $Url...&quot;

    # Increase timeout to ~5 minutes (150 * 2s) to handle slow network initialization
    $maxRetries = 150
    $retry = 0
    $connected = $false

    # Wait for network
    while (-not $connected -and $retry -lt $maxRetries) {
        try {
            $null = [System.Net.Dns]::GetHostEntry(&quot;8.8.8.8&quot;)
            $connected = $true
        } catch {
            $retry++
            Start-Sleep -Seconds 2
        }
    }

    if ($connected) {
        try {
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-WebRequest -Uri $Url -OutFile $Destination -UseBasicParsing -ErrorAction Stop
            if (Test-Path -Path $Destination -And (Get-Item $Destination).Length -gt 0) {
                Write-Log &quot;Download of $Name successful.&quot;
                return $true
            }
        } catch {
            Write-Log &quot;Failed to download $Name: $_&quot;
        }
    } else {
        Write-Log &quot;No network connectivity to download $Name.&quot;
    }
    return $false
}
		</File>
		<File path="C:\Windows\Setup\Scripts\Drivers\Install-Network.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

Write-Log &quot;Starting Network Driver Installation...&quot;
$mediaRoot = Get-InstallMedia

if ($mediaRoot) {
    $driverPath = Join-Path -Path $mediaRoot -ChildPath &quot;drivers\network&quot;
    if (Test-Path -Path $driverPath) {
        Write-Log &quot;Found network drivers at $driverPath&quot;
        try {
            $pnputilArgs = &quot;/add-driver `&quot;$driverPath\*.inf`&quot; /subdirs /install&quot;
            # Redirect standard output/error to null for total silence
            Start-Process -FilePath &quot;pnputil.exe&quot; -ArgumentList $pnputilArgs -Wait -NoNewWindow -RedirectStandardOutput &quot;$env:TEMP\pnputil_network.log&quot;
            Write-Log &quot;Network driver installation completed.&quot;
        }
        catch {
            Write-Log &quot;Error installing network drivers: $_&quot;
        }
    } else {
        Write-Log &quot;No network drivers found in $driverPath&quot;
    }
} else {
    Write-Log &quot;Install media not found.&quot;
}
		</File>
		<File path="C:\Windows\Setup\Scripts\Drivers\Install-Nvidia.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

Write-Log &quot;Starting Nvidia Driver Installation...&quot;
$mediaRoot = Get-InstallMedia
$setupPath = $null

# Online check removed due to API deprecation.
# To use a direct download, set the URL below manually or use the local drivers folder.
# $url = &quot;https://...&quot;

# Try Local (Fallback/Primary)
if (-not $setupPath -and $mediaRoot) {
    Write-Log &quot;Checking local storage...&quot;
    $driverDir = Join-Path -Path $mediaRoot -ChildPath &quot;drivers\nvidia&quot;
    $setupPath = Get-InstallerFile -Path $driverDir
}

if ($setupPath) {
    Write-Log &quot;Installing Nvidia driver from $setupPath...&quot;
    try {
        Unblock-File -Path $setupPath -ErrorAction SilentlyContinue
        # -s: Silent, -n: No splash, -f: Force, -noreboot: No reboot
        Start-Process -FilePath $setupPath -ArgumentList '-s -n -f -noreboot' -Wait -NoNewWindow -RedirectStandardOutput &quot;$env:TEMP\nvidia_install.log&quot;
        Write-Log &quot;Nvidia driver installation completed.&quot;
    }
    catch {
        Write-Log &quot;Error installing Nvidia drivers: $_&quot;
    }
} else {
    Write-Log &quot;Nvidia installer not found locally.&quot;
}
		</File>
		<File path="C:\Windows\Setup\Scripts\Drivers\Install-AMD.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

# OPTIONAL: Set a direct download URL for the AMD Chipset Driver here.
$DownloadUrl = &quot;&quot;

Write-Log &quot;Starting AMD Chipset Driver Installation...&quot;
$mediaRoot = Get-InstallMedia
$setupPath = $null

if ($mediaRoot) {
    $driverDir = Join-Path -Path $mediaRoot -ChildPath &quot;drivers\amd&quot;
    $setupPath = Get-InstallerFile -Path $driverDir
}

if (-not $setupPath -and $DownloadUrl) {
    $dest = &quot;$env:TEMP\amd_chipset.exe&quot;
    if (Download-File -Url $DownloadUrl -Destination $dest -Name &quot;AMD Chipset&quot;) {
        $setupPath = $dest
    }
}

if ($setupPath) {
    Write-Log &quot;Installing AMD driver from $setupPath...&quot;
    try {
        Unblock-File -Path $setupPath -ErrorAction SilentlyContinue
        # /S: Silent
        Start-Process -FilePath $setupPath -ArgumentList &quot;/S&quot;, &quot;-noreboot&quot; -Wait -NoNewWindow -RedirectStandardOutput &quot;$env:TEMP\amd_install.log&quot;
        Write-Log &quot;AMD Chipset driver installation completed.&quot;
    }
    catch {
        Write-Log &quot;Error installing AMD Chipset drivers: $_&quot;
    }
} else {
    Write-Log &quot;AMD installer not found locally and no download URL provided.&quot;
}
		</File>
		<File path="C:\Windows\Setup\Scripts\Drivers\Install-Focusrite.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

# OPTIONAL: Set a direct download URL for the Focusrite Driver here.
$DownloadUrl = &quot;&quot;

Write-Log &quot;Starting Focusrite Driver Installation...&quot;
$mediaRoot = Get-InstallMedia
$setupPath = $null

if ($mediaRoot) {
    $driverDir = Join-Path -Path $mediaRoot -ChildPath &quot;drivers\focusrite&quot;
    $setupPath = Get-InstallerFile -Path $driverDir
}

if (-not $setupPath -and $DownloadUrl) {
    $dest = &quot;$env:TEMP\focusrite_driver.exe&quot;
    if (Download-File -Url $DownloadUrl -Destination $dest -Name &quot;Focusrite Driver&quot;) {
        $setupPath = $dest
    }
}

if ($setupPath) {
    Write-Log &quot;Installing Focusrite driver from $setupPath...&quot;
    try {
        Unblock-File -Path $setupPath -ErrorAction SilentlyContinue
        # /VERYSILENT: No UI, /SUPPRESSMSGBOXES: No popups
        Start-Process -FilePath $setupPath -ArgumentList '/VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-' -Wait -NoNewWindow -RedirectStandardOutput &quot;$env:TEMP\focusrite_install.log&quot;
        Write-Log &quot;Focusrite driver installation completed.&quot;
    }
    catch {
        Write-Log &quot;Error installing Focusrite drivers: $_&quot;
    }
} else {
    Write-Log &quot;Focusrite installer not found locally and no download URL provided.&quot;
}
		</File>
		<File path="C:\Windows\Setup\Scripts\Apps\Install-Runtimes.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

Write-Log &quot;Starting Visual C++ Runtimes Installation...&quot;

# Official Microsoft Link for Latest Supported VC++ 2015-2022
$url64 = &quot;https://aka.ms/vc14/vc_redist.x64.exe&quot;
$url86 = &quot;https://aka.ms/vc14/vc_redist.x86.exe&quot;

$dest64 = &quot;$env:TEMP\vc_redist.x64.exe&quot;
$dest86 = &quot;$env:TEMP\vc_redist.x86.exe&quot;

# Install x64
if (Download-File -Url $url64 -Destination $dest64 -Name &quot;Visual C++ Runtimes (x64)&quot;) {
    Write-Log &quot;Installing Visual C++ Runtimes (x64)...&quot;
    try {
        Unblock-File -Path $dest64 -ErrorAction SilentlyContinue
        Start-Process -FilePath $dest64 -ArgumentList &quot;/install /quiet /norestart&quot; -Wait -NoNewWindow -RedirectStandardOutput &quot;$env:TEMP\vcredist_x64_install.log&quot;
        Write-Log &quot;Visual C++ Runtimes (x64) installation completed.&quot;
    } catch {
        Write-Log &quot;Error installing Visual C++ Runtimes (x64): $_&quot;
    }
} else {
    Write-Log &quot;Failed to download Visual C++ Runtimes (x64).&quot;
}

# Install x86
if (Download-File -Url $url86 -Destination $dest86 -Name &quot;Visual C++ Runtimes (x86)&quot;) {
    Write-Log &quot;Installing Visual C++ Runtimes (x86)...&quot;
    try {
        Unblock-File -Path $dest86 -ErrorAction SilentlyContinue
        Start-Process -FilePath $dest86 -ArgumentList &quot;/install /quiet /norestart&quot; -Wait -NoNewWindow -RedirectStandardOutput &quot;$env:TEMP\vcredist_x86_install.log&quot;
        Write-Log &quot;Visual C++ Runtimes (x86) installation completed.&quot;
    } catch {
        Write-Log &quot;Error installing Visual C++ Runtimes (x86): $_&quot;
    }
} else {
    Write-Log &quot;Failed to download Visual C++ Runtimes (x86).&quot;
}
		</File>
		<File path="C:\Windows\Setup\Scripts\Apps\Install-Chrome.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

Write-Log &quot;Starting Chrome Installation...&quot;
$mediaRoot = Get-InstallMedia
$setupPath = $null

# 1. Try Download (Online First)
$url = 'https://dl.google.com/chrome/install/chrome_installer.exe'
$dest = &quot;$env:TEMP\chrome.exe&quot;
if (Download-File -Url $url -Destination $dest -Name &quot;Chrome&quot;) {
    $setupPath = $dest
}

# 2. Try Local (Fallback)
if (-not $setupPath -and $mediaRoot) {
    Write-Log &quot;Download failed. Checking local storage...&quot;
    $possiblePaths = @(
        (Join-Path $mediaRoot &quot;apps\chrome&quot;),
        (Join-Path $mediaRoot &quot;drivers\apps\chrome&quot;),
        (Join-Path $mediaRoot &quot;Apps&quot;),
        (Join-Path $mediaRoot &quot;Drivers\Apps&quot;)
    )
    foreach ($path in $possiblePaths) {
         if (Test-Path $path) {
             $localInstaller = Get-InstallerFile -Path $path
             if ($localInstaller) {
                $setupPath = $localInstaller
                break
             }
         }
    }
}

if ($setupPath) {
    Write-Log &quot;Installing Chrome from $setupPath...&quot;
    try {
        Unblock-File -Path $setupPath -ErrorAction SilentlyContinue
        Start-Process -FilePath $setupPath -ArgumentList '/silent /install' -Wait -NoNewWindow -RedirectStandardOutput &quot;$env:TEMP\chrome_install.log&quot;
        if ($setupPath -eq &quot;$env:TEMP\chrome.exe&quot;) {
            Remove-Item -Path $setupPath -Force -ErrorAction SilentlyContinue
        }
        Write-Log &quot;Chrome installation completed.&quot;
    } catch {
        Write-Log &quot;Error installing Chrome: $_&quot;
    }
} else {
    Write-Log &quot;Chrome installer not found locally and download failed.&quot;
}
		</File>
		<File path="C:\Windows\Setup\Scripts\Tweaks\Remove-Bloatware.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

$packagesToRemove = @(
    'Microsoft.Microsoft3DViewer',
    'Microsoft.BingSearch',
    'Microsoft.WindowsCamera',
    'Clipchamp.Clipchamp',
    'Microsoft.WindowsAlarms',
    'Microsoft.Copilot',
    'Microsoft.Windows.DevHome',
    'MicrosoftCorporationII.MicrosoftFamily',
    'Microsoft.WindowsFeedbackHub',
    'Microsoft.GetHelp',
    'Microsoft.Getstarted',
    'microsoft.windowscommunicationsapps',
    'Microsoft.WindowsMaps',
    'Microsoft.MixedReality.Portal',
    'Microsoft.BingNews',
    'Microsoft.WindowsNotepad',
    'Microsoft.MicrosoftOfficeHub',
    'Microsoft.Office.OneNote',
    'Microsoft.OutlookForWindows',
    'Microsoft.MSPaint',
    'Microsoft.People',
    'Microsoft.Windows.Photos',
    'Microsoft.PowerAutomateDesktop',
    'MicrosoftCorporationII.QuickAssist',
    'Microsoft.SkypeApp',
    'Microsoft.MicrosoftSolitaireCollection',
    'Microsoft.MicrosoftStickyNotes',
    'MicrosoftTeams',
    'MSTeams',
    'Microsoft.Todos',
    'Microsoft.WindowsSoundRecorder',
    'Microsoft.Wallet',
    'Microsoft.BingWeather',
    'Microsoft.ZuneVideo',
    'Microsoft.Windows.Ai.Copilot.Provider'
)

$capabilitiesToRemove = @(
    'Print.Fax.Scan',
    'Browser.InternetExplorer',
    'MathRecognizer',
    'OneCoreUAP.OneSync',
    'App.Support.QuickAssist',
    'App.StepsRecorder',
    'Hello.Face',
    'Media.WindowsMediaPlayer',
    'Microsoft.Windows.WordPad'
)

$featuresToRemove = @(
    'MediaPlayback',
    'Microsoft-RemoteDesktopConnection',
    'Recall'
)

Write-Log &quot;Starting Debloating Process...&quot;

# Remove Appx Provisioned Packages
$provisioned = Get-AppxProvisionedPackage -Online
foreach ($package in $packagesToRemove) {
    $found = $provisioned | Where-Object { $_.DisplayName -eq $package }
    if ($found) {
        Write-Log &quot;Removing $package...&quot;
        try {
            Remove-AppxProvisionedPackage -Online -PackageName $found.PackageName -ErrorAction Continue | Out-Null
        } catch {
            Write-Log &quot;Failed to remove $package: $_&quot;
        }
    }
}

# Remove Capabilities
$capabilities = Get-WindowsCapability -Online
foreach ($capName in $capabilitiesToRemove) {
    $cap = $capabilities | Where-Object { ($_.Name -split '~')[0] -eq $capName -and $_.State -ne 'NotPresent' }
    if ($cap) {
        Write-Log &quot;Removing capability $capName...&quot;
        try {
            Remove-WindowsCapability -Online -Name $cap.Name -ErrorAction Continue | Out-Null
        } catch {
            Write-Log &quot;Failed to remove capability $capName: $_&quot;
        }
    }
}

# Remove Optional Features
foreach ($feature in $featuresToRemove) {
    if ((Get-WindowsOptionalFeature -Online -FeatureName $feature -ErrorAction SilentlyContinue).State -eq 'Enabled') {
        Write-Log &quot;Disabling feature $feature...&quot;
        try {
            Disable-WindowsOptionalFeature -Online -FeatureName $feature -Remove -NoRestart -ErrorAction Continue | Out-Null
        } catch {
            Write-Log &quot;Failed to disable feature $feature: $_&quot;
        }
    }
}

Write-Log &quot;Debloating Process Completed.&quot;
		</File>
		<File path="C:\Windows\Setup\Scripts\Tweaks\Configure-Privacy.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

Write-Log &quot;Applying Privacy and Registry Tweaks...&quot;

# Disable Telemetry and Data Collection
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows\DataCollection&quot; /v AllowTelemetry /t REG_DWORD /d 0 /f
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows\DataCollection&quot; /v DoNotShowFeedbackNotifications /t REG_DWORD /d 1 /f
reg.exe add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\DataCollection&quot; /v AllowTelemetry /t REG_DWORD /d 0 /f

# Disable Bing Search and Cortana
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Search&quot; /v AllowCortana /t REG_DWORD /d 0 /f
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Search&quot; /v DisableWebSearch /t REG_DWORD /d 1 /f
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Search&quot; /v ConnectedSearchUseWeb /t REG_DWORD /d 0 /f
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows\Windows Search&quot; /v AllowCloudSearch /t REG_DWORD /d 0 /f

# Disable Copilot
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsCopilot&quot; /v TurnOffWindowsCopilot /t REG_DWORD /d 1 /f
reg.exe add &quot;HKCU\Software\Policies\Microsoft\Windows\WindowsCopilot&quot; /v TurnOffWindowsCopilot /t REG_DWORD /d 1 /f

# Disable News and Interests
reg.exe add &quot;HKLM\SOFTWARE\Policies\Microsoft\Dsh&quot; /v AllowNewsAndInterests /t REG_DWORD /d 0 /f

# Disable Edge First Run and Bloat
reg.exe add &quot;HKLM\Software\Policies\Microsoft\Edge&quot; /v HideFirstRunExperience /t REG_DWORD /d 1 /f
reg.exe add &quot;HKLM\Software\Policies\Microsoft\Edge\Recommended&quot; /v BackgroundModeEnabled /t REG_DWORD /d 0 /f
reg.exe add &quot;HKLM\Software\Policies\Microsoft\Edge\Recommended&quot; /v StartupBoostEnabled /t REG_DWORD /d 0 /f

# Disable BitLocker Automatic Device Encryption
reg.exe add &quot;HKLM\SYSTEM\CurrentControlSet\Control\BitLocker&quot; /v &quot;PreventDeviceEncryption&quot; /t REG_DWORD /d 1 /f

# Disable VBS/HVCI (Performance)
reg.exe add &quot;HKLM\System\CurrentControlSet\Control\DeviceGuard&quot; /v &quot;EnableVirtualizationBasedSecurity&quot; /t REG_DWORD /d 0 /f
reg.exe add &quot;HKLM\System\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity&quot; /v &quot;Enabled&quot; /t REG_DWORD /d 0 /f

# Classic Context Menu (Windows 11) - Requires HKCU, handled in UserOnce or DefaultUser
# Here we can try setting it for default user via reg load or just rely on UserOnce

Write-Log &quot;Privacy Tweaks Applied.&quot;

		</File>
		<File path="C:\Windows\Setup\Scripts\Tweaks\SetStartPins.ps1">
$json = '{&quot;pinnedList&quot;:[]}';
if( [System.Environment]::OSVersion.Version.Build -lt 20000 ) {
	return;
}
$key = 'Registry::HKLM\SOFTWARE\Microsoft\PolicyManager\current\device\Start';
New-Item -Path $key -ItemType 'Directory' -ErrorAction 'SilentlyContinue';
Set-ItemProperty -LiteralPath $key -Name 'ConfigureStartPins' -Value $json -Type 'String';

		</File>
		<File path="C:\Windows\Setup\Scripts\Specialize.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

$scripts = @(
    &quot;$PSScriptRoot\Drivers\Install-Network.ps1&quot;,
    &quot;$PSScriptRoot\Tweaks\Remove-Bloatware.ps1&quot;,
    &quot;$PSScriptRoot\Tweaks\Configure-Privacy.ps1&quot;,
    &quot;$PSScriptRoot\Drivers\Install-Nvidia.ps1&quot;,
    &quot;$PSScriptRoot\Drivers\Install-AMD.ps1&quot;,
    &quot;$PSScriptRoot\Drivers\Install-Focusrite.ps1&quot;,
    "$PSScriptRoot\Apps\Install-Runtimes.ps1",
    &quot;$PSScriptRoot\Apps\Install-Chrome.ps1&quot;,
    &quot;$PSScriptRoot\Tweaks\SetStartPins.ps1&quot;
)

Write-Log &quot;Starting Specialize Pass (Optimized)...&quot;

foreach ($script in $scripts) {
    if (Test-Path $script) {
        Write-Log &quot;Executing $script...&quot;
        try {
            &amp; $script
        } catch {
            Write-Log &quot;Error executing $script: $_&quot;
        }
    } else {
        Write-Log &quot;Script not found: $script&quot;
    }
}

# Generate SetupComplete.cmd for post-OOBE cleanup
# This ensures unattend.xml remains available for OOBE but is removed before login
$setupCompleteContent = @&quot;
del /q /f &quot;%WINDIR%\Panther\unattend.xml&quot;
del /q /f &quot;%WINDIR%\Panther\unattend-original.xml&quot;
&quot;@

$setupCompletePath = &quot;$env:SystemRoot\Setup\Scripts\SetupComplete.cmd&quot;
try {
    Set-Content -Path $setupCompletePath -Value $setupCompleteContent -Force
    Write-Log &quot;Generated SetupComplete.cmd for cleanup.&quot;
} catch {
    Write-Log &quot;Error creating SetupComplete.cmd: $_&quot;
}

Write-Log &quot;Specialize Pass Completed.&quot;

		</File>
		<File path="C:\Windows\Setup\Scripts\DefaultUser.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

Write-Log &quot;Configuring Default User...&quot;

# Load Default User Hive
$defaultUserHive = &quot;HKU\DefaultUser&quot;
reg.exe load $defaultUserHive &quot;C:\Users\Default\NTUSER.DAT&quot;

try {
    # Taskbar and Explorer settings
    reg.exe add &quot;$defaultUserHive\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced&quot; /v ShowTaskViewButton /t REG_DWORD /d 0 /f
    reg.exe add &quot;$defaultUserHive\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced&quot; /v TaskbarAl /t REG_DWORD /d 0 /f # Left align taskbar
    reg.exe add &quot;$defaultUserHive\Software\Policies\Microsoft\Windows\Explorer&quot; /v DisableSearchBoxSuggestions /t REG_DWORD /d 1 /f

    # Show File Extensions
    reg.exe add &quot;$defaultUserHive\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced&quot; /v HideFileExt /t REG_DWORD /d 0 /f

    # Classic Context Menu (Windows 11)
    reg.exe add &quot;$defaultUserHive\Software\Classes\CLSID\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\InprocServer32&quot; /ve /t REG_SZ /d &quot;&quot; /f

    # Disable Copilot for Default User
    reg.exe add &quot;$defaultUserHive\Software\Policies\Microsoft\Windows\WindowsCopilot&quot; /v TurnOffWindowsCopilot /t REG_DWORD /d 1 /f

    # Run UserOnce on first login
    reg.exe add &quot;$defaultUserHive\Software\Microsoft\Windows\CurrentVersion\RunOnce&quot; /v &quot;UnattendedSetup&quot; /t REG_SZ /d &quot;powershell.exe -WindowStyle `&quot;Normal`&quot; -ExecutionPolicy `&quot;Unrestricted`&quot; -NoProfile -File `&quot;C:\Windows\Setup\Scripts\UserOnce.ps1`&quot;&quot; /f
}
finally {
    reg.exe unload $defaultUserHive
    [GC]::Collect()
}

Write-Log &quot;Default User Configuration Completed.&quot;

		</File>
		<File path="C:\Windows\Setup\Scripts\UserOnce.ps1">
$ErrorActionPreference = 'Stop'
. &quot;$PSScriptRoot\Lib\Helper.ps1&quot;

Write-Log &quot;Configuring User Account...&quot;

# Disable Copilot
Get-AppxPackage -Name 'Microsoft.Windows.Ai.Copilot.Provider' | Remove-AppxPackage -ErrorAction SilentlyContinue

# Explorer Settings
Set-ItemProperty -LiteralPath 'Registry::HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced' -Name 'LaunchTo' -Type 'DWord' -Value 1 -Force
Set-ItemProperty -LiteralPath 'Registry::HKCU\Software\Microsoft\Windows\CurrentVersion\Search' -Name 'SearchboxTaskbarMode' -Type 'DWord' -Value 3 -Force # Icon only

# Restart Explorer to apply changes
Get-Process -Name 'explorer' -ErrorAction 'SilentlyContinue' | Stop-Process -Force

# Register Daily Winget Auto-Update Task (Transparent)
$taskName = "DailySoftwareUpdate"
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -Command `&quot;winget source update; winget upgrade --all --include-unknown --silent --accept-source-agreements --accept-package-agreements`&quot;"
$trigger = New-ScheduledTaskTrigger -Daily -At 13:00
$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable -Hidden -RunOnlyIfNetworkAvailable
Register-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -TaskName $taskName -Description "Automatically updates all software via Winget silently." -RunLevel Highest -Force | Out-Null
Write-Log "Registered Daily Winget Auto-Update Task."

Write-Log &quot;User Configuration Completed.&quot;

		</File>

	</Extensions>
</unattend>
